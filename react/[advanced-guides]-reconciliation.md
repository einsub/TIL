# 조정(Reconciliation)

*React는 선언적(declarative) API를 제공하므로 업데이트마다 무엇이 변경되는지 걱정 할 필요 없습니다. 이로 인해 애플리케이션을 작성하기 무척 쉬워지지만, React 안에서 어떻게 구현되었는지는 명확하게 알기 어렵습니다. 이 글은 React의 "diffing" 알고리즘에서 우리가 선택한 것들, 그리고 이것이 컴포넌트의 업데이트를 예측 가능하게 하고 빠르고 성능 좋은 앱을 만들게 해준다는 점을 알아봅니다.*

---

## 동기

React를 사용 할 때, `render()` 함수가 React 엘리먼트들의 트리를 만드는 어느 한 시점을 생각해 볼 수 있습니다. state나 props의 다음 업데이트가 있을 때, 그 `render()` 함수는 React 엘리먼트들의 다른 트리를 반환할 것입니다. 그러면 React는 어떻게 하면 UI를 가장 최근의 트리와 효율적으로 일치 시킬 수 있을지 알아내야 합니다.

이와 같이 하나의 트리를 다른 트리로 변환 할 때 최소한의 작업을 사용하는 알고리즘 문제에는 몇 가지 일반적인 해결 방법이 있습니다. 그러나, [최첨단(state of the art) 알고리즘](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)은 O(n3)의 복잡도를 가지며, 여기서 n은 트리 안의 엘리먼트 개수입니다.

React에서 이 알고리즘을 사용한다면, 1,000개의 엘리먼트에 대해 10억개의 비교가 필요합니다. 이것은 너무나 비싼 비용입니다. React는 대신 두 가지 가정에 따라 경험적 O(n) 알고리즘을 구현합니다.

1. 다른 타입의 엘리먼트들은 다른 트리를 만들어 낼 것이다.
2. 개발자는 `key` prop을 이용해 서로 다른 렌더링 과정에서 어떤 자식 엘리먼트가 안정적인지 힌트를 얻을 수 있다.

경험상, 이 가정들은 대부분의 실제 유즈 케이스에서 유효합니다.

---

## Diffing 알고리즘

두 트리의 다른 점을 찾아낼 때, React는 먼저 두 루트 엘리먼트를 비교합니다. 루트 엘리먼트의 타입에 따라 동작이 다릅니다.

### 다른 타입의 엘리먼트들

루트 엘리먼트들이 서로 다른 타입을 가지고 있을 때 마다, React는 새로 트리를 만들어서 기존의 트리와 갈라놓습니다. `<a>`에서 `<img>`, `<Article>`에서 `<Comment>`로, `<Button>`에서 `<div>`로 - 이 중 무엇이든 완전히 새로운 빌드를 이끌어 냅니다.

트리를 쪼갤 때, 기존의 DOM 노드들은 제거됩니다. 컴포넌트 인스턴스글은 `componentWillUnmount()`를 받게 됩니다. 새 트리를 만들 때, 새 DOM 노드들이 DOM에 추가됩니다. 컴포넌트들은 `componentWillMount()`와 `componentDidMount()`를 차례로 받습니다. 기존 트리와 연결되어있던 모든 state들은 없어집니다.

루트의 밑에 있던 어떤 컴포넌트들이라도 언마운트 되며 state가 제거됩니다. 예를 들어, 다음의 차이 비교를 하면:

```html
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

이는 기존의 `Counter`를 지우고 새 것을 다시 마운트 하게 됩니다.

### 같은 타입의 DOM 엘리먼트

두 같은 타입의 React DOM 엘리먼트들을 비교할 때, React는 각각의 속성들을 살펴보고 기저의 동일한 DOM 노드는 유지한 채, 변경된 속성들만 업데트합니다. 예를 들면:

```html
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

이 두 엘리먼트들의 비교로 인해, React는 기저의 DOM 노드위에서 `className`만 변경되었다는 것을 압니다.

`style`을 업데이트 할 때도 React는 변경된 속성들만 업데이트 할 것임을 압니다. 예를 들면:

```html
<div style={{color: 'red', fontWeight: 'bold'}}>

<div style={{color: 'green', fontWeight: 'bold'}}>
```

이 두 엘리먼트의 변환 과정에서, React는 `fontWeight`가 아닌 `color`만 수정한다는 것을 압니다.

DOM 노드를 처리한 후, React는 자식들에 대해 재귀적으로 처리합니다.

### 같은 타입의 컴포넌트 엘리먼트들

컴포넌트가 업데이트되면, 인스턴스는 동일하게 유지되므로 렌더링간의 state가 유지됩니다. React는 새 엘리먼트와 일치하도록 기저의 컴포넌트 인스턴스의 props를 업데이트하고, `componentWillReceiveProps()`와 `componentWillUpdate()`를 호출합니다.

다음, `render()` 메소드가 호출되고, 기존의 결과와 최신의 결과에 대해 diff 알고리즘이 반복적으로 적용됩니다.

### 자식에서의 반복 

기본적으로, DOM 노드의 자식들에 대해 반복 할 때 React는 두 자식 목록을 반복 실행하고 차이가 있을 때 마다 변형을 시킵니다.

예를 들어, 자식 엘리먼트의 끝에 엘리먼트를 추가할 때, 두 트리 사이의 변형은 잘 동작합니다.

```html
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React는 `<li>first</li>` 트리를 일치시키고, `<li>second<li>` 트리를 일치시키고, `<li>third</li>` 트리를 추가합니다.

순진하게 구하면 처음에 엘리먼트를 삽입하는 경우 성능이 떨어집니다. 예를 들어, 다음 두 트리 사이의 변환은 성능이 나쁩니다:

```html
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

React는 `<li>Duke</li>`와 `<li>Villanova</li>` 하뒤 트리를 그대로 가지고 있어도 괜찮다는 것을 깨닫지 못하고, 모든 자식들을 변형시키버립니다.

### 키

이 문제를 해결하기 위해, React는 `키(key)` 속성을 제공합니다. 자식들이 키를 가지고 있으면, React는 키를 사용하여 원래 트리의 하위 트리와 하위 트리의 하위 트리를 비교합니다. 예를 들어서, 아까의 비효율적인 예제에 `키`를 추가하면 트리 변환을 효율적으로 만들 수 있습니다:

```html
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

이제 React는 키 `2014`의 엘리먼트가 새 것이고, `2015`와 `2016`은 그냥 옮겨졌다는 것을 압니다.

실전적으로, 키를 찾는 것은 보통 어렵지 않습니다. 보여주려는 엘리먼트는 아마도 유일한 ID를 이미 가지고 있을 것이므로, 그냥 데이터에서 키를 가지고 오는게 가능합니다:

```html
<li key={item.id}>{item.name}</li>
```

그렇지 않은 경우, 모델에 새로운 ID 속성을 추가하거나 내용의 일부를 해시하여 키를 생성 할 수 있습니다. 키는 그 형제들 사이에서 유일하기만 하면 되고, 전체적으로는 유일하지 않아도 됩니다.

마지막 방법으로, 배열의 항목 인덱스를 키로 전달 할 수 있습니다. 아이템 순서가 한번도 재정렬이 되지 않았다면, 느리긴 하겠지만 잘 작동합니다.

인덱스를 키로 사용하면 재정렬이 컴포넌트의 state와 문제를 일으킬 수도 있습니다. 컴포넌트 인스턴스들은 그 키를 기반으로 업데이트되고 재사용됩니다. 키가 index라면, 아이템을 이동하면 해당 항목이 변경됩니다. 결과적으로 통제되지 않는 입력과 같은 컴포넌트의 상태가 뒤죽박죽 되어 예상치 못한 방식으로 업데이트 되어 버릴 수 있습니다.

이 [예제](https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key)는 인덱스를 키로 사용하여 발생하는 이슈를 CodePen에서 입력해둔 것입니다. 그리고 이 [예제](https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key)는 똑같은 예제이지만, 키로 인덱스를 쓰지 않아서 발생한 재배열, 정렬, 우선 처리 문제를 수정한 버전입니다.

---

## Tradeoffs

조정 알고리즘은 세부 구현 내용이라는 점을 기억하는 것이 중요합니다. React는 모든 액션마다 전체 앱을 다시 렌더링 할 수도 있습니다; 최종 결과는 어차피 똑같습니다. 명확히 하기 위해 다시 이야기하자면, 여기서의 rerender는 모든 컴포넌트에 `render`를 호출한다는 의미입니다. React가 그것들을 언마운트 하고 다시 마운트를 한다는 의미가 아닙니다. 이전 섹션에서 명시한 규칙을 따라 서로 다른 부분만 적용하게 됩니다.

우리는 일반적인 유즈 케이스를 빠르게 만들기 위해 정기적으로 휴리스틱(hruristics)을 수정하고 있습니다. 현 구현에서는 하위 트리가 형제 사이에서 이동되었다는 사실을 표현할 수 있지만 다른 곳으로 이동했다고 말할 수는 없습니다. 알고리즘은 해당 전체 하위 트리를 다시 렌더링합니다.

React가 경험적 방법에 의존하기 때문에, 그 뒤에 있는 가정이 충족되지 않으면 성능이 저하됩니다.

1. 알고리즘은 서로 다른 컴포넌트 타입의 하위 트리들끼리는 일치시키려 하지 않을 것입니다. 출력이 매우 유사한 두 컴포넌트 타입을 서로 번갈아 사용하는 경우 타입을 동일하게 지정 할 수 있습니다. 실제로 우리는 이것이 문제가 되지 않는다는 것을 알았습니다.
2. 키는 안정적이고 예측 가능해야 하며, 유일해야 합니다. 안정적이지 않은 키 (`Math.random()` 으로 만들어진 것 같은)는 여러 컴포넌트 인스턴스들과 DOM 노드들을 필요 이상으로 다시 만들게 됩니다. 이는 성능 저하를 일으키고, 자식 컴포넌트들의 state를 잃어버리게 합니다.